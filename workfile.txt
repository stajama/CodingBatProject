// --- Logic-2


// noTeenSum

// 
// Given 3 int values, a b c, return their sum. However, if any of the values is a
//  teen -- in the range 13..19 inclusive -- then that value counts as 0, except 1
// 5 and 16 do not count as a teens. Write a separate helper "public int fixTeen(i
// nt n) {"that takes in an int value and returns that value fixed for the teen ru
// le. In this way, you avoid repeating the teen code 3 times (i.e. "decomposition
// "). Define the helper below and at the same indent level as the main noTeenSum(
// ).

// roundSum

// 
// For this problem, we'll round an int value up to the next multiple of 10 if its
//  rightmost digit is 5 or more, so 15 rounds up to 20. Alternately, round down t
// o the previous multiple of 10 if its rightmost digit is less than 5, so 12 roun
// ds down to 10. Given 3 ints, a b c, return the sum of their rounded values. To 
// avoid code repetition, write a separate helper "public int round10(int num) {" 
// and call it 3 times. Write the helper entirely below and at the same indent lev
// el as roundSum().

// evenlySpaced

// 
// Given three ints, a b c, one of them is small, one is medium and one is large. 
// Return true if the three values are evenly spaced, so the difference between sm
// all and medium is the same as the difference between medium and large.

// makeBricks

// 
// We want to make a row of bricks that is 

// blackjack

// 
// Given 2 int values greater than 0, return whichever value is nearest to 21 with
// out going over. Return 0 if they both go over.

// loneSum

// 
// Given 3 int values, a b c, return their sum. However, if one of the values is t
// he same as another of the values, it does not count towards the sum.

// makeChocolate

// 
// We want make a package of 

// luckySum

// 
// Given 3 int values, a b c, return their sum. However, if one of the values is 1
// 3 then it does not count towards the sum and values to its right do not count. 
// So for example, if b is 13, then both b and c do not count.

// closeFar

// 
// Given three ints, a b c, return true if one of b or c is "close" (differing fro
// m a by at most 1), while the other is "far", differing from both other values b
// y 2 or more. Note: Math.abs(num) computes the absolute value of a number.

// --- Array-2


// centeredAverage

// 
// Return the "centered" average of an array of ints, which we'll say is the mean 
// average of the values, except ignoring the largest and smallest values in the a
// rray. If there are multiple copies of the smallest value, ignore just one copy,
//  and likewise for the largest value. Use int division to produce the final aver
// age. You may assume that the array is length 3 or more.

// post4

// 
// Given a non-empty array of ints, return a new array containing the elements fro
// m the original array that come after the last 4 in the original array. The orig
// inal array will contain at least one 4. Note that it is valid in java to create
//  an array of length 0.

// fizzBuzz

// 
// This is slightly more difficult version of the famous FizzBuzz problem which is
//  sometimes given as a first problem for job interviews. (See also: 

// zeroFront

// 
// Return an array that contains the exact same numbers as the given array, but re
// arranged so that all the zeros are grouped at the start of the array. The order
//  of the non-zero numbers does not matter. So {1, 0, 0, 1} becomes {0 ,0, 1, 1}.
//  You may modify and return the given array or make a new array.

// tripleUp

// 
// Return true if the array contains, somewhere, three increasing adjacent numbers
//  like .... 4, 5, 6, ... or 23, 24, 25.

// matchUp

// 
// Given arrays nums1 and nums2 of the same length, for every element in nums1, co
// nsider the corresponding element in nums2 (at the same index). Return the count
//  of the number of times that the two elements differ by 2 or less, but are not 
// equal.

// sum13

// 
// Return the sum of the numbers in the array, returning 0 for an empty array. Exc
// ept the number 13 is very unlucky, so it does not count and numbers that come i
// mmediately after a 13 also do not count.

// haveThree

// 
// Given an array of ints, return true if the value 3 appears in the array exactly
//  3 times, and no 3's are next to each other.

// fizzArray2

// 
// Given a number n, create and return a new string array of length n, containing 
// the strings "0", "1" "2" .. through n-1. N may be 0, in which case just return 
// a length 0 array. Note: String.valueOf(xxx) will make the String form of most t
// ypes. The syntax to make a new string array is: new String[desired_length]  (S
// ee also: 

// has77

// 
// Given an array of ints, return true if the array contains two 7's next to each 
// other, or there are two 7's separated by one element, such as with {7, 1, 7}.

// notAlone

// 
// We'll say that an element in an array is "alone" if there are values before and
//  after it, and those values are different from it. Return a version of the give
// n array where every instance of the given value which is alone is replaced by w
// hichever value to its left or right is larger.

// countEvens

// 
// Return the number of even ints in the given array. Note: the % "mod" operator c
// omputes the remainder, e.g. 5 % 2 is 1.

// has12

// 
// Given an array of ints, return true if there is a 1 in the array with a 2 somew
// here later in the array.

// tenRun

// 
// For each multiple of 10 in the given array, change all the values following it 
// to be that multiple of 10, until encountering another multiple of 10. So {2, 10
// , 3, 4, 20, 5} yields {2, 10, 10, 10, 20, 20}.

// evenOdd

// 
// Return an array that contains the exact same numbers as the given array, but re
// arranged so that all the even numbers come before all the odd numbers. Other th
// an that, the numbers can be in any order. You may modify and return the given a
// rray, or make a new array.

// isEverywhere

// 
// We'll say that a value is "everywhere" in an array if for every pair of adjacen
// t elements in the array, at least one of the pair is that value. Return true if
//  the given value is everywhere in the array.

// only14

// 
// Given an array of ints, return true if every element is a 1 or a 4.

// shiftLeft

// 
// Return an array that is "left shifted" by one -- so {6, 2, 5, 3} returns {2, 5,
//  3, 6}. You may modify and return the given array, or return a new array.

// lucky13

// 
// Given an array of ints, return true if the array contains no 1's and no 3's.

// sameEnds

// 
// Return true if the group of N numbers at the start and end of the array are the
//  same. For example, with {5, 6, 45, 99, 13, 5, 6}, the ends are the same for n=
// 0 and n=2, and false for n=1 and n=3. You may assume that n is in the range 0..
// nums.length inclusive.

// withoutTen

// 
// Return a version of the given array where all the 10's have been removed. The r
// emaining elements should shift left towards the start of the array as needed, a
// nd the empty spaces a the end of the array should be 0. So {1, 10, 10, 2} yield
// s {1, 2, 0, 0}. You may modify and return the given array or make a new array.

// 
// sum67

// 
// Return the sum of the numbers in the array, except ignore sections of numbers s
// tarting with a 6 and extending to the next 7 (every 6 will be followed by at le
// ast one 7). Return 0 for no numbers.

// pre4

// 
// Given a non-empty array of ints, return a new array containing the elements fro
// m the original array that come before the first 4 in the original array. The or
// iginal array will contain at least one 4. Note that it is valid in java to crea
// te an array of length 0.

// bigDiff

// 
// Given an array length 1 or more of ints, return the difference between the larg
// est and smallest values in the array. Note: the built-in Math.min(v1, v2) and M
// ath.max(v1, v2) methods  return the smaller or larger of two values.

// zeroMax

// 
// Return a version of the given array where each zero value in the array is repla
// ced by the largest odd value to the right of the zero in the array. If there is
//  no odd value to the right of the zero, leave the zero as a zero.

// modThree

// 
// Given an array of ints, return true if the array contains either 3 even or 3 od
// d values all next to each other.

// sum28

// 
// Given an array of ints, return true if the sum of all the 2's in the array is e
// xactly 8.

// fizzArray

// 
// Given a number n, create and return a new int array of length n, containing the
//  numbers 0, 1, 2, ... n-1. The given n may be 0, in which case just return a le
// ngth 0 array. You do not need a separate if-statement for the length-0 case; th
// e for-loop should naturally execute 0 times in that case, so it just works. The
//  syntax to make a new int array is: new int[desired_length]    (See also: 

// no14

// 
// Given an array of ints, return true if it contains no 1's or it contains no 4's
// .

// twoTwo

// 
// Given an array of ints, return true if every 2 that appears in the array is nex
// t to another 2.

// more14

// 
// Given an array of ints, return true if the number of 1's is greater than the nu
// mber of 4's

// fizzArray3

// 
// Given 

// has22

// 
// Given an array of ints, return true if the array contains a 2 next to a 2 somew
// here.

// either24

// 
// Given an array of ints, return true if the array contains a 2 next to a 2 or a 
// 4 next to a 4, but not both.

// --- Array-1


// makeLast

// 
// Given an int array, return a new array with double the length where its last el
// ement is the same as the original array, and all the other elements are 0. The 
// original array will be length 1 or more. Note: by default, a new int array cont
// ains all 0's.

// commonEnd

// 
// Given 2 arrays of ints, a and b, return true if they have the same first elemen
// t or they have the same last element. Both arrays will be length 1 or more.

// front11

// 
// Given 2 int arrays, a and b, of any length, return a new array with the first e
// lement of each array. If either array is length 0, ignore that array.

// sum3

// 
// Given an array of ints length 3, return the sum of all the elements.

// sum2

// 
// Given an array of ints, return the sum of the first 2 elements in the array. If
//  the array length is less than 2, just sum up the elements that exist, returnin
// g 0 if the array is length 0.

// biggerTwo

// 
// Start with 2 int arrays, a and b, each length 2. Consider the sum of the values
//  in each array. Return the array which has the largest sum. In event of a tie, 
// return a.

// sameFirstLast

// 
// Given an array of ints, return true if the array is length 1 or more, and the f
// irst element and the last element are equal.

// reverse3

// 
// Given an array of ints length 3, return a new array with the elements in revers
// e order, so {1, 2, 3} becomes {3, 2, 1}.

// frontPiece

// 
// Given an int array of any length, return a new array of its first 2 elements. I
// f the array is smaller than length 2, use whatever elements are present.

// no23

// 
// Given an int array length 2, return true if it does not contain a 2 or 3.

// start1

// 
// Start with 2 int arrays, a and b, of any length. Return how many of the arrays 
// have 1 as their first element.

// firstLast6

// 
// Given an array of ints, return true if 6 appears as either the first or last el
// ement in the array. The array will be length 1 or more.

// midThree

// 
// Given an array of ints of odd length, return a new array length 3 containing th
// e elements from the middle of the array. The array length will be at least 3.

// maxTriple

// 
// Given an array of ints of odd length, look at the first, last, and middle value
// s in the array and return the largest. The array length will be a least 1.

// make2

// 
// Given 2 int arrays, a and b, return a new array length 2 containing, as much as
//  will fit, the elements from a followed by the elements from b. The arrays may 
// be any length, including 0, but there will be 2 or more elements available betw
// een the 2 arrays.

// double23

// 
// Given an int array, return true if the array contains 2 twice, or 3 twice. The 
// array will be length 0, 1, or 2.

// plusTwo

// 
// Given 2 int arrays, each length 2, return a new array length 4 containing all t
// heir elements.

// swapEnds

// 
// Given an array of ints, swap the first and last elements in the array. Return t
// he modified array. The array length will be at least 1.

// unlucky1

// 
// We'll say that a 1 immediately followed by a 3 in an array is an "unlucky" 1. R
// eturn true if the given array contains an unlucky 1 in the first 2 or last 2 po
// sitions in the array.

// makeMiddle

// 
// Given an array of ints of even length, return a new array length 2 containing t
// he middle two elements from the original array. The original array will be leng
// th 2 or more.

// makePi

// 
// Return an int array length 3 containing the first 3 digits of pi, {3, 1, 4}.

// fix23

// 
// Given an int array length 3, if there is a 2 in the array immediately followed 
// by a 3, set the 3 element to 0. Return the changed array.

// rotateLeft3

// 
// Given an array of ints length 3, return an array with the elements "rotated lef
// t" so {1, 2, 3} yields {2, 3, 1}.

// middleWay

// 
// Given 2 int arrays, a and b, each length 3, return a new array length 2 contain
// ing their middle elements.

// has23

// 
// Given an int array length 2, return true if it contains a 2 or a 3.

// makeEnds

// 
// Given an array of ints, return a new array length 2 containing the first and la
// st elements from the original array. The original array will be length 1 or mor
// e.

// maxEnd3

// 
// Given an array of ints length 3, figure out which is larger, the first or last 
// element in the array, and set all the other elements to be that value. Return t
// he changed array.

// --- Logic-1


// old35

// 
// Return true if the given non-negative number is a multiple of 3 or 5, but not b
// oth. Use the % "mod" operator -- see 

// less20

// 
// Return true if the given non-negative number is 1 or 2 

// lessBy10

// 
// Given three ints, a b c, return true if one of them is 10 or more less than one
//  of the others.

// fizzString2

// 
// Given an int n, return the string form of the number followed by "!". So the in
// t 6 yields "6!". Except if the number is divisible by 3 use "Fizz" instead of t
// he number, and if the number is divisible by 5 use "Buzz", and if divisible by 
// both 3 and 5, use "FizzBuzz". Note: the % "mod" operator computes the remainder
//  after division, so 23 % 10 yields 3. What will the remainder be when one numbe
// r divides evenly into another? (See also: 

// teaParty

// 
// We are having a party with amounts of tea and candy. Return the int outcome of 
// the party encoded as 0=bad, 1=good, or 2=great. A party is good (1) if both tea
//  and candy are at least 5. However, if either tea or candy is at least double t
// he amount of the other one, the party is great (2). However, in all cases, if e
// ither tea or candy is less than 5, the party is always bad (0).

// squirrelPlay

// 
// The squirrels in Palo Alto spend most of the day playing. In particular, they p
// lay if the temperature is between 60 and 90 (inclusive). Unless it is summer, t
// hen the upper limit is 100 instead of 90. Given an int temperature and a boolea
// n isSummer, return true if the squirrels play and false otherwise.

// in1To10

// 
// Given a number n, return true if n is in the range 1..10, inclusive. Unless out
// sideMode is true, in which case return true if the number is less or equal to 1
// , or greater or equal to 10.

// twoAsOne

// 
// Given three ints, a b c, return true if it is possible to add two of the ints t
// o get the third.

// blueTicket

// 
// You have a blue lottery ticket, with ints a, b, and c on it. This makes three p
// airs, which we'll call ab, bc, and ac. Consider the sum of the numbers in each 
// pair. If any pair sums to exactly 10, the result is 10. Otherwise if the ab sum
//  is exactly 10 more than either bc or ac sums, the result is 5. Otherwise the r
// esult is 0.

// alarmClock

// 
// Given a day of the week encoded as 0=Sun, 1=Mon, 2=Tue, ...6=Sat, and a boolean
//  indicating if we are on vacation, return a string of the form "7:00" indicatin
// g when the alarm clock should ring. Weekdays, the alarm should be "7:00" and on
//  the weekend it should be "10:00". Unless we are on vacation -- then on weekday
// s it should be "10:00" and weekends it should be "off".

// greenTicket

// 
// You have a green lottery ticket, with ints a, b, and c on it. If the numbers ar
// e all different from each other, the result is 0. If all of the numbers are the
//  same, the result is 20. If two of the numbers are the same, the result is 10.

// 
// love6

// 
// The number 6 is a truly great number. Given two int values, a and b, return tru
// e if either one is 6. Or if their sum or difference is 6. Note: the function Ma
// th.abs(num) computes the absolute value of a number.

// shareDigit

// 
// Given two ints, each in the range 10..99, return true if there is a digit that 
// appears in both numbers, such as the 2 in 12 and 23. (Note: division, e.g. n/10
// , gives the left digit while the % "mod" n%10 gives the right digit.)

// dateFashion

// 
// You and your date are trying to get a table at a restaurant. The parameter "you
// " is the stylishness of your clothes, in the range 0..10, and "date" is the sty
// lishness of your date's clothes. The result getting the table is encoded as an 
// int value with 0=no, 1=maybe, 2=yes. If either of you is very stylish, 8 or mor
// e, then the result is 2 (yes). With the exception that if either of you has sty
// le of 2 or less, then the result is 0 (no). Otherwise the result is 1 (maybe).

// 
// more20

// 
// Return true if the given non-negative number is 1 or 2 more than a multiple of 
// 20. See also: 

// maxMod5

// 
// Given two int values, return whichever value is larger. However if the two valu
// es have the same remainder when divided by 5, then the return the smaller value
// . However, in all cases, if the two values are the same, return 0. Note: the % 
// "mod" operator computes the remainder, e.g. 7 % 5 is 2.

// cigarParty

// 
// When squirrels get together for a party, they like to have cigars. A squirrel p
// arty is successful when the number of cigars is between 40 and 60, inclusive. U
// nless it is the weekend, in which case there is no upper bound on the number of
//  cigars. Return true if the party with the given values is successful, or false
//  otherwise.

// withoutDoubles

// 
// Return the sum of two 6-sided dice rolls, each in the range 1..6. However, if n
// oDoubles is true, if the two dice show the same value, increment one die to the
//  next value, wrapping around to 1 if its value was 6.

// lastDigit

// 
// Given three ints, a b c, return true if two or more of them have the same right
// most digit. The ints are non-negative. Note: the % "mod" operator computes the 
// remainder, e.g. 17 % 10 is 7.

// teenSum

// 
// Given 2 ints, a and b, return their sum. However, "teen" values in the range 13
// ..19 inclusive, are extra lucky. So if either value is a teen, just return 19.

// 
// redTicket

// 
// You have a red lottery ticket showing ints a, b, and c, each of which is 0, 1, 
// or 2. If they are all the value 2, the result is 10. Otherwise if they are all 
// the same, the result is 5. Otherwise so long as both b and c are different from
//  a, the result is 1. Otherwise the result is 0.

// inOrder

// 
// Given three ints, a b c, return true if b is greater than a, and c is greater t
// han b. However, with the exception that if "bOk" is true, b does not need to be
//  greater than a.

// inOrderEqual

// 
// Given three ints, a b c, return true if they are in strict increasing order, su
// ch as 2 5 11, or 5 6 7, but not 6 5 7 or 5 5 7. However, with the exception tha
// t if "equalOk" is true, equality is allowed, such as 5 5 7 or 5 5 5.

// sumLimit

// 
// Given 2 non-negative ints, a and b, return their sum, so long as the sum has th
// e same number of digits as a. If the sum has more digits than a, just return a 
// without b. (Note: one way to compute the number of digits of a non-negative int
//  n is to convert it to a string with String.valueOf(n) and then check the lengt
// h of the string.)

// fizzString

// 
// Given a string str, if the string starts with "f" return "Fizz". If the string 
// ends with "b" return "Buzz". If both the "f" and "b" conditions are true, retur
// n "FizzBuzz". In all other cases, return the string unchanged. (See also: 

// answerCell

// 
// Your cell phone rings. Return true if you should answer it. Normally you answer
// , except in the morning you only answer if it is your mom calling. In all cases
// , if you are asleep, you do not answer.

// specialEleven

// 
// We'll say a number is special if it is a multiple of 11 or if it is one more th
// an a multiple of 11. Return true if the given non-negative number is special. U
// se the % "mod" operator -- see 

// nearTen

// 
// Given a non-negative number "num", return true if num is within 2 of a multiple
//  of 10. Note: (a % b) is the remainder of dividing a by b, so (7 % 5) is 2. See
//  also: 

// caughtSpeeding

// 
// You are driving a little too fast, and a police officer stops you. Write code t
// o compute the result, encoded as an int value: 0=no ticket, 1=small ticket, 2=b
// ig ticket. If speed is 60 or less, the result is 0. If speed is between 61 and 
// 80 inclusive, the result is 1. If speed is 81 or more, the result is 2. Unless 
// it is your birthday -- on that day, your speed can be 5 higher in all cases.

// sortaSum

// 
// Given 2 ints, a and b, return their sum. However, sums in the range 10..19 incl
// usive, are forbidden, so in that case just return 20.

// --- Functional-2


// square56

// 
// Given a list of integers, return a list of those numbers squared and the produc
// t added to 10, omitting any of the resulting numbers that end in 5 or 6.

// noTeen

// 
// Given a list of integers, return a list of those numbers, omitting any that are
//  between 13 and 19 inclusive.

// no34

// 
// Given a list of strings, return a list of the strings, omitting any string leng
// th 3 or 4.

// noNeg

// 
// Given a list of integers, return a list of the integers, omitting any that are 
// less than 0.

// no9

// 
// Given a list of non-negative integers, return a list of those numbers except om
// itting any that end with 9. (Note:  % by 10)

// noZ

// 
// Given a list of strings, return a list of the strings, omitting any string that
//  contains a "z". (Note: the str.contains(x) method returns a boolean)

// noYY

// 
// Given a list of strings, return a list where each string has "y" added at its e
// nd, omitting any resulting strings that contain "yy" as a substring anywhere.

// two2

// 
// Given a list of non-negative integers, return a list of those numbers multiplie
// d by 2, omitting any of the resulting numbers that end in 2.

// noLong

// 
// Given a list of strings, return a list of the strings, omitting any string leng
// th 4 or more.

// --- AP-1


// matchUp

// 
// Given 2 arrays that are the same length containing strings, compare the 1st str
// ing in one array to the 1st string in the other array, the 2nd to the 2nd and s
// o on. Count the number of times that the 2 strings are non-empty and start with
//  the same char. The strings may be any length, including 0.

// dividesSelf

// 
// We'll say that a positive int divides itself if every digit in the number divid
// es into the number evenly. So for example 128 divides itself since 1, 2, and 8 
// all divide into 128 evenly. We'll say that 0 does not divide into anything even
// ly, so no number with a 0 digit divides itself. Note: use % to get the rightmos
// t digit, and / to discard the rightmost digit.

// wordsFront

// 
// Given an array of strings, return a new array containing the first N strings. N
//  will be in the range 1..length.

// scoresAverage

// 
// Given an array of scores, compute the int average of the first half and the sec
// ond half, and return whichever is larger. We'll say that the second half begins
//  at index length/2. The array length will be at least 2. To practice decomposit
// ion, write a separate helper method 

// bigHeights

// 
// (A variation on the sumHeights problem.) We have an array of heights, represent
// ing the altitude along a walking trail. Given start/end indexes into the array,
//  return the number of "big" steps for a walk starting at the start index and en
// ding at the end index. We'll say that  step is big if it is 5 or more up or dow
// n. The start end end index will both be valid indexes into the array with start
//  &lt;= end.

// sumHeights

// 
// We have an array of heights, representing the altitude along a walking trail. G
// iven start/end indexes into the array, return the sum of the changes for a walk
//  beginning at the start index and ending at the end index. For example, with th
// e heights {5, 3, 6, 7, 2} and start=2, end=4 yields a sum of 1 + 5 = 6. The sta
// rt end end index will both be valid indexes into the array with start &lt;= end
// .

// mergeTwo

// 
// Start with two arrays of strings, A and B, each with its elements in alphabetic
// al order and without duplicates. Return a new array containing the first N elem
// ents from the two arrays. The result array should be in alphabetical order and 
// without duplicates. A and B will both have a length which is N or more. The bes
// t "linear" solution makes a single pass over A and B, taking advantage of the f
// act that they are in alphabetical order, copying elements directly to the new a
// rray.

// sumHeights2

// 
// (A variation on the sumHeights problem.) We have an array of heights, represent
// ing the altitude along a walking trail. Given start/end indexes into the array,
//  return the sum of the changes for a walk beginning at the start index and endi
// ng at the end index, however increases in height count double. For example, wit
// h the heights {5, 3, 6, 7, 2} and start=2, end=4 yields a sum of 1*2 + 5 = 7. T
// he start end end index will both be valid indexes into the array with start &lt
// ;= end.

// scoreUp

// 
// The "key" array is an array containing the correct answers to an exam, like {"a
// ", "a", "b", "b"}. the "answers" array contains a student's answers, with "?" r
// epresenting a question left blank. The two arrays are not empty and are the sam
// e length. Return the score for this array of answers, giving +4 for each correc
// t answer, -1 for each incorrect answer, and +0 for each blank answer.

// copyEndy

// 
// We'll say that a positive int n is "endy" if it is in the range 0..10 or 90..10
// 0 (inclusive). Given an array of positive ints, return a new array of length "c
// ount" containing the first endy numbers from the original array. Decompose out 
// a separate isEndy(int n) method to test if a number is endy. The original array
//  will contain at least "count" endy numbers.

// wordsWithout

// 
// Given an array of strings, return a new array without the strings that are equa
// l to the target string. One approach is to count the occurrences of the target 
// string, make a new array of the correct length, and then copy over the correct 
// strings.

// scoresClump

// 
// Given an array of scores sorted in increasing order, return true if the array c
// ontains 3 adjacent scores that differ from each other by at most 2, such as wit
// h {3, 4, 5} or {3, 5, 5}.

// hasOne

// 
// Given a positive int n, return true if it contains a 1 digit. Note: use % to ge
// t the rightmost digit, and / to discard the rightmost digit.

// copyEvens

// 
// Given an array of positive ints, return a new array of length "count" containin
// g the first even numbers from the original array. The original array will conta
// in at least "count" even numbers.

// scoresIncreasing

// 
// Given an array of scores, return true if each score is equal or greater than th
// e one before. The array will be length 2 or more.

// wordsWithoutList

// 
// Given an array of strings, return a new List (e.g. an ArrayList) where all the 
// strings of the given length are omitted. See wordsWithout() below which is more
//  difficult because it uses arrays.

// commonTwo

// 
// Start with two arrays of strings, a and b, each in alphabetical order, possibly
//  with duplicates. Return the count of the number of strings which appear in bot
// h arrays. The best "linear" solution makes a single pass over both arrays, taki
// ng advantage of the fact that they are in alphabetical order.

// scoresSpecial

// 
// Given two arrays, A and B, of non-negative int scores. A "special" score is one
//  which is a multiple of 10, such as 40 or 90. Return the sum of largest special
//  score in A and the largest special score in B. To practice decomposition, writ
// e a separate helper method which finds the largest special score in an array. W
// rite your helper method after your scoresSpecial() method in the JavaBat text a
// rea.

// wordsCount

// 
// Given an array of strings, return the count of the number of strings with the g
// iven length.

// scores100

// 
// Given an array of scores, return true if there are scores of 100 next to each o
// ther in the array. The array length will be at least 2.

// userCompare

// 
// We have data for two users, A and B, each with a String name and an int id. The
//  goal is to order the users such as for sorting. Return -1 if A comes before B,
//  1 if A comes after B, and 0 if they are the same. Order first by the string na
// mes, and then by the id numbers if the names are the same. Note: with Strings s
// tr1.compareTo(str2) returns an int value which is negative/0/positive to indica
// te how str1 is ordered to str2 (the value is not limited to -1/0/1). (On the AP
// , there would be two User objects, but here the code simply takes the two strin
// gs and two ints directly. The code logic is the same.)

// --- Map-2


// wordMultiple

// 
// Given an array of strings, return a Map&lt;String, Boolean&gt; where each diffe
// rent string is a key and its value is true if that string appears 2 or more tim
// es in the array.

// pairs

// 
// Given an array of non-empty strings, create and return a Map&lt;String, String&
// gt; as follows: for each string add its first character as a key with its last 
// character as the value.

// wordLen

// 
// Given an array of strings, return a Map&lt;String, Integer&gt; containing a key
//  for every different string in the array, and the value is that string's length
// .

// allSwap

// 
// We'll say that 2 strings "match" if they are non-empty and their first chars ar
// e the same. Loop over and then return the given array of non-empty strings as f
// ollows: if a string matches an earlier string in the array, swap the 2 strings 
// in the array. When a position in the array has been swapped, it no longer match
// es anything. Using a map, this can be solved making just one pass over the arra
// y. More difficult than it looks.

// wordCount

// 
// The classic word-count algorithm: given an array of strings, return a Map&lt;St
// ring, Integer&gt; with a key for each different string, with the value the numb
// er of times that string appears in the array.

// wordAppend

// 
// Loop over the given array of strings to build a result string like this: when a
//  string appears the 2nd, 4th, 6th, etc. time in the array, append the string to
//  the result. Return the empty string if no string appears a 2nd time.

// word0

// 
// Given an array of strings, return a Map&lt;String, Integer&gt; containing a key
//  for every different string in the array, always with the value 0. For example 
// the string "hello" makes the pair "hello":0. We'll do more complicated counting
//  later, but for this problem the value is simply 0.

// firstSwap

// 
// We'll say that 2 strings "match" if they are non-empty and their first chars ar
// e the same. Loop over and then return the given array of non-empty strings as f
// ollows: if a string matches an earlier string in the array, swap the 2 strings 
// in the array. A particular first char can only cause 1 swap, so once a char has
//  caused a swap, its later swaps are disabled. Using a map, this can be solved m
// aking just one pass over the array. More difficult than it looks.

// firstChar

// 
// Given an array of non-empty strings, return a Map&lt;String, String&gt; with a 
// key for every different first character seen, with the value of all the strings
//  starting with that character appended together in the order they appear in the
//  array.

// --- Recursion-1


// array220

// 
// Given an array of ints, compute recursively if the array contains somewhere a v
// alue followed in the array by that value times 10. We'll use the convention of 
// considering only the part of the array that begins at the given index. In this 
// way, a recursive call can pass index+1 to move down the array. The initial call
//  will pass in index as 0.

// stringClean

// 
// Given a string, return recursively a "cleaned" string where adjacent chars that
//  are the same have been reduced to a single char. So "yyzzza" yields "yza".

// fibonacci

// 
// The fibonacci sequence is a famous bit of mathematics, and it happens to have a
//  recursive definition. The first two values in the sequence are 0 and 1 (essent
// ially 2 base cases). Each subsequent value is the sum of the previous two value
// s, so the whole sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21 and so on. Define a re
// cursive fibonacci(n) method that returns the nth fibonacci number, with n=0 rep
// resenting the start of the sequence.

// strCount

// 
// Given a string and a non-empty substring 

// parenBit

// 
// Given a string that contains a single pair of parenthesis, compute recursively 
// a new string made of only of the parenthesis and their contents, so "xyz(abc)12
// 3" yields "(abc)".

// changeXY

// 
// Given a string, compute recursively (no loops) a new string where all the lower
// case 'x' chars have been changed to 'y' chars.

// strDist

// 
// Given a string and a non-empty substring 

// array11

// 
// Given an array of ints, compute recursively the number of times that the value 
// 11 appears in the array. We'll use the convention of considering only the part 
// of the array that begins at the given index. In this way, a recursive call can 
// pass index+1 to move down the array. The initial call will pass in index as 0.

// 
// strCopies

// 
// Given a string and a non-empty substring 

// count11

// 
// Given a string, compute recursively (no loops) the number of "11" substrings in
//  the string. The "11" substrings should not overlap.

// array6

// 
// Given an array of ints, compute recursively if the array contains a 6. We'll us
// e the convention of considering only the part of the array that begins at the g
// iven index. In this way, a recursive call can pass index+1 to move down the arr
// ay. The initial call will pass in index as 0.

// sumDigits

// 
// Given a non-negative int n, return the sum of its digits recursively (no loops)
// . Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while div
// ide (/) by 10 removes the rightmost digit (126 / 10 is 12).

// countX

// 
// Given a string, compute recursively (no loops) the number of lowercase 'x' char
// s in the string.

// allStar

// 
// Given a string, compute recursively a new string where all the adjacent chars a
// re now separated by a "*".

// countPairs

// 
// We'll say that a "pair" in a string is two instances of a char separated by a c
// har. So "AxA" the A's make a pair. Pair's can overlap, so "AxAxA" contains 3 pa
// irs -- 2 for A and 1 for x. Recursively compute the number of pairs in the give
// n string.

// bunnyEars

// 
// We have a number of bunnies and each bunny has two big floppy ears. We want to 
// compute the total number of ears across all the bunnies recursively (without lo
// ops or multiplication).

// powerN

// 
// Given 

// triangle

// 
// We have triangle made of blocks. The topmost row has 1 block, the next row down
//  has 2 blocks, the next row has 3 blocks, and so on. Compute recursively (no lo
// ops or multiplication) the total number of blocks in such a triangle with the g
// iven number of rows.

// factorial

// 
// Given n of 1 or more, return the factorial of n, which is n * (n-1) * (n-2) ...
//  1. Compute the result recursively (without loops).

// nestParen

// 
// Given a string, return true if it is a nesting of zero or more pairs of parenth
// esis, like "(())" or "((()))". Suggestion: check the first and last chars, and 
// then recur on what's inside them.

// count8

// 
// Given a non-negative int n, compute recursively (no loops) the count of the occ
// urrences of 8 as a digit, except that an 8 with another 8 immediately to its le
// ft counts double, so 8818 yields 4. Note that mod (%) by 10 yields the rightmos
// t digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit (12
// 6 / 10 is 12).

// countAbc

// 
// Count recursively the total number of "abc" and "aba" substrings that appear in
//  the given string.

// countHi

// 
// Given a string, compute recursively (no loops) the number of times lowercase "h
// i" appears in the string.

// count7

// 
// Given a non-negative int n, return the count of the occurrences of 7 as a digit
// , so for example 717 yields 2. (no loops). Note that mod (%) by 10 yields the r
// ightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost di
// git (126 / 10 is 12).

// bunnyEars2

// 
// We have bunnies standing in a line, numbered 1, 2, ... The odd bunnies (1, 3, .
// .) have the normal 2 ears. The even bunnies (2, 4, ..) we'll say have 3 ears, b
// ecause they each have a raised foot. Recursively return the number of "ears" in
//  the bunny line 1, 2, ... n (without loops or multiplication).

// changePi

// 
// Given a string, compute recursively (no loops) a new string where all appearanc
// es of "pi" have been replaced by "3.14".

// countHi2

// 
// Given a string, compute recursively the number of times lowercase "hi" appears 
// in the string, however do not count "hi" that have an 'x' immedately before the
// m.

// noX

// 
// Given a string, compute recursively a new string where all the 'x' chars have b
// een removed.

// endX

// 
// Given a string, compute recursively a new string where all the lowercase 'x' ch
// ars have been moved to the end of the string.

// pairStar

// 
// Given a string, compute recursively a new string where identical chars that are
//  adjacent in the original string are separated from each other by a "*".

// --- Recursion-2


// splitArray

// 
// Given an array of ints, is it possible to divide the ints into two groups, so t
// hat the sums of the two groups are the same. Every int must be in one group or 
// the other. Write a recursive helper method that takes whatever arguments you li
// ke, and make the initial call to your recursive helper from splitArray(). (No l
// oops needed.)

// groupSum

// 
// Given an array of ints, is it possible to choose a group of some of the ints, s
// uch that the group sums to the given target? This is a classic backtracking rec
// ursion problem. Once you understand the recursive backtracking strategy in this
//  problem, you can use the same pattern for many problems to search a space of c
// hoices. Rather than looking at the whole array, our convention is to consider t
// he part of the array starting at index 

// groupNoAdj

// 
// Given an array of ints, is it possible to choose a group of some of the ints, s
// uch that the group sums to the given target with this additional constraint: If
//  a value in the array is chosen to be in the group, the value immediately follo
// wing it in the array must not be chosen. (No loops needed.)

// splitOdd10

// 
// Given an array of ints, is it possible to divide the ints into two groups, so t
// hat the sum of one group is a multiple of 10, and the sum of the other group is
//  odd. Every int must be in one group or the other. Write a recursive helper met
// hod that takes whatever arguments you like, and make the initial call to your r
// ecursive helper from splitOdd10(). (No loops needed.)

// groupSumClump

// 
// Given an array of ints, is it possible to choose a group of some of the ints, s
// uch that the group sums to the given target, with this additional constraint: i
// f there are numbers in the array that are adjacent and the identical value, the
// y must either all be chosen, or none of them chosen. For example, with the arra
// y {1, 2, 2, 2, 5, 2}, either all three 2's in the middle must be chosen or not,
//  all as a group. (one loop can be used to find the extent of the identical valu
// es).

// groupSum6

// 
// Given an array of ints, is it possible to choose a group of some of the ints, b
// eginning at the start index, such that the group sums to the given target? Howe
// ver, with the additional constraint that all 6's must be chosen. (No loops need
// ed.)

// groupSum5

// 
// Given an array of ints, is it possible to choose a group of some of the ints, s
// uch that the group sums to the given target with these additional constraints: 
// all multiples of 5 in the array must be included in the group. If the value imm
// ediately following a multiple of 5 is 1, it must not be chosen. (No loops neede
// d.)

// split53

// 
// Given an array of ints, is it possible to divide the ints into two groups, so t
// hat the sum of the two groups is the same, with these constraints: all the valu
// es that are multiple of 5 must be in one group, and all the values that are a m
// ultiple of 3 (and not a multiple of 5) must be in the other. (No loops needed.)
// 

// --- Functional-1


// addStar

// 
// Given a list of strings, return a list where each string has "*" added at its e
// nd.

// square

// 
// Given a list of integers, return a list where each integer is multiplied with i
// tself.

// moreY

// 
// Given a list of strings, return a list where each string has "y" added at its s
// tart and end.

// rightDigit

// 
// Given a list of non-negative integers, return an integer list of the rightmost 
// digits. (Note: use %)

// lower

// 
// Given a list of strings, return a list where each string is converted to lower 
// case (Note: String toLowerCase() method).

// noX

// 
// Given a list of strings, return a list where each string has all its "x" remove
// d.

// copies3

// 
// Given a list of strings, return a list where each string is replaced by 3 copie
// s of the string concatenated together.

// doubling

// 
// Given a list of integers, return a list where each integer is multiplied by 2.

// 
// math1

// 
// Given a list of integers, return a list where each integer is added to 1 and th
// e result is multiplied by 10.

// --- String-1


// withoutEnd

// 
// Given a string, return a version without the first and last char, so "Hello" yi
// elds "ell". The string length will be at least 2.

// left2

// 
// Given a string, return a "rotated left 2" version where the first 2 chars are m
// oved to the end. The string length will be at least 2.

// middleThree

// 
// Given a string of odd length, return the string length 3 from its middle, so "C
// andy" yields "and". The string length will be at least 3.

// withoutX

// 
// Given a string, if the first or last chars are 'x', return the string without t
// hose 'x' chars, and otherwise return the string unchanged.

// theEnd

// 
// Given a string, return a string length 1 from its front, unless 

// firstHalf

// 
// Given a string of even length, return the first half. So the string "WooHoo" yi
// elds "Woo".

// nTwice

// 
// Given a string and an int n, return a string made of the first and last n chars
//  from the string. The string length will be at least n.

// extraEnd

// 
// Given a string, return a new string made of 3 copies of the last 2 chars of the
//  original string. The string length will be at least 2.

// twoChar

// 
// Given a string and an index, return a string length 2 starting at the given ind
// ex. If the index is too big or too small to define a string length 2, use the f
// irst 2 chars. The string length will be at least 2.

// comboString

// 
// Given 2 strings, a and b, return a string of the form short+long+short, with th
// e shorter string on the outside and the longer string on the inside. The string
// s will not be the same length, but they may be empty (length 0).

// right2

// 
// Given a string, return a "rotated right 2" version where the last 2 chars are m
// oved to the start. The string length will be at least 2.

// lastTwo

// 
// Given a string of any length, return a new string where the last 2 chars, if pr
// esent, are swapped, so "coding" yields "codign".

// middleTwo

// 
// Given a string of even length, return a string made of the middle two chars, so
//  the string "string" yields "ri". The string length will be at least 2.

// firstTwo

// 
// Given a string, return the string made of its first two chars, so the String "H
// ello" yields "He". If the string is shorter than length 2, return whatever ther
// e is, so "X" yields "X", and the empty string "" yields the empty string "". No
// te that str.length() returns the length of a string.

// frontAgain

// 
// Given a string, return true if the first 2 chars in the string also appear at t
// he end of the string, such as with "edited".

// withoutX2

// 
// Given a string, if one or both of the first 2 chars is 'x', return the string w
// ithout those 'x' chars, and otherwise return the string unchanged. This is a li
// ttle harder than it looks.

// atFirst

// 
// Given a string, return a string length 2 made of its first 2 chars. If the stri
// ng length is less than 2, use '@' for the missing chars.

// hasBad

// 
// Given a string, return true if "bad" appears starting at index 0 or 1 in the st
// ring, such as with "badxxx" or "xbadxx" but not "xxbadxx". The string may be an
// y length, including 0. Note: use .equals() to compare 2 strings.

// lastChars

// 
// Given 2 strings, a and b, return a new string made of the first char of a and t
// he last char of b, so "yo" and "java" yields "ya". If either string is length 0
// , use '@' for its missing char.

// helloName

// 
// Given a string name, e.g. "Bob", return a greeting of the form "Hello Bob!".

// startWord

// 
// Given a string and a second "word" string, we'll say that the word matches the 
// string if it appears at the front of the string, except its first char does not
//  need to match exactly. On a match, return the front of the string, or otherwis
// e return the empty string. So, so with the string "hippo" the word "hi" returns
//  "hi" and "xip" returns "hip". The word will be at least length 1.

// deFront

// 
// Given a string, return a version without the first 2 chars. Except keep the fir
// st char if it is 'a' and keep the second char if it is 'b'. The string may be a
// ny length. Harder than it looks.

// endsLy

// 
// Given a string, return true if it ends in "ly".

// nonStart

// 
// Given 2 strings, return their concatenation, except omit the first char of each
// . The strings will be at least length 1.

// without2

// 
// Given a string, if a length 2 substring appears at both its beginning and end, 
// return a string without the substring at the beginning, so "HelloHe" yields "ll
// oHe". The substring may overlap with itself, so "Hi" yields "". Otherwise, retu
// rn the original string unchanged.

// makeAbba

// 
// Given two strings, a and b, return the result of putting them together in the o
// rder abba, e.g. "Hi" and "Bye" returns "HiByeByeHi".

// withouEnd2

// 
// Given a string, return a version without both the first and last char of the st
// ring. The string may be any length, including 0.

// seeColor

// 
// Given a string, if the string begins with "red" or "blue" return that color str
// ing, otherwise return the empty string.

// extraFront

// 
// Given a string, return a new string made of 3 copies of the first 2 chars of th
// e original string. The string may be any length. If there are fewer than 2 char
// s, use whatever is there.

// makeOutWord

// 
// Given an "out" string length 4, such as "&lt;&lt;&gt;&gt;", and a word, return 
// a new string where the word is in the middle of the out string, e.g. "&lt;&lt;w
// ord&gt;&gt;". Note: use str.substring(i, j) to extract the String starting at i
// ndex i and going up to but not including index j.

// minCat

// 
// Given two strings, append them together (known as "concatenation") and return t
// he result. However, if the strings are different lengths, omit chars from the l
// onger string so it is the same length as the shorter string. So "Hello" and "Hi
// " yield "loHi". The strings may be any length.

// makeTags

// 
// The web is built with HTML strings like "&lt;i&gt;Yay&lt;/i&gt;" which draws Ya
// y as italic text. In this example, the "i" tag makes &lt;i&gt; and &lt;/i&gt; w
// hich surround the word "Yay". Given tag and word strings, create the HTML strin
// g with tags around the word, e.g. "&lt;i&gt;Yay&lt;/i&gt;".

// conCat

// 
// Given two strings, append them together (known as "concatenation") and return t
// he result. However, if the concatenation creates a double-char, then omit one o
// f the chars, so "abc" and "cat" yields "abcat".

// --- String-2


// repeatSeparator

// 
// Given two strings, 

// plusOut

// 
// Given a string and a non-empty 

// countCode

// 
// Return the number of times that the string "code" appears anywhere in the given
//  string, except we'll accept any letter for the 'd', so "cope" and "cooe" count
// .

// mixString

// 
// Given two strings, 

// oneTwo

// 
// Given a string, compute a new string by moving the first char to come after the
//  next two chars, so "abc" yields "bca". Repeat this process for each subsequent
//  group of 3 chars, so "abcdef" yields "bcaefd". Ignore any group of fewer than 
// 3 chars at the end.

// xyzThere

// 
// Return true if the given string contains an appearance of "xyz" where the xyz i
// s not directly preceeded by a period (.). So "xxyz" counts but "x.xyz" does not
// .

// starOut

// 
// Return a version of the given string, where for every star (*) in the string th
// e star and the chars immediately to its left and right are gone. So "ab*cd" yie
// lds "ad" and "ab**cd" also yields "ad".

// prefixAgain

// 
// Given a string, consider the prefix string made of the first N chars of the str
// ing. Does that prefix string appear somewhere else in the string? Assume that t
// he string is not empty and that N is in the range 1..str.length().

// catDog

// 
// Return true if the string "cat" and "dog" appear the same number of times in th
// e given string.

// doubleChar

// 
// Given a string, return a string where for every char in the original, there are
//  two chars.

// wordEnds

// 
// Given a string and a non-empty 

// xyBalance

// 
// We'll say that a String is xy-balanced if for all the 'x' chars in the string, 
// there exists a 'y' char somewhere later in the string. So "xxy" is balanced, bu
// t "xyx" is not. One 'y' can balance multiple 'x's. Return true if the given str
// ing is xy-balanced.

// zipZap

// 
// Look for patterns like "zip" and "zap" in the string -- length-3, starting with
//  'z' and ending with 'p'. Return a string where for all such words, the middle 
// letter is gone, so "zipXzap" yields "zpXzp".

// repeatFront

// 
// Given a string and an int n, return a string made of the first n characters of 
// the string, followed by the first n-1 characters of the string, and so on. You 
// may assume that n is between 0 and the length of the string, inclusive (i.e. n 
// &gt;= 0 and n &lt;= str.length()).

// bobThere

// 
// Return true if the given string contains a "bob" string, but where the middle '
// o' char can be any char.

// sameStarChar

// 
// Returns true if for every '*' (star) in the string, if there are chars both imm
// ediately before and after the star, they are the same.

// countHi

// 
// Return the number of times that the string "hi" appears anywhere in the given s
// tring.

// getSandwich

// 
// A sandwich is two pieces of bread with something in between. Return the string 
// that is between the first and last appearance of "bread" in the given string, o
// r return the empty string "" if there are not two pieces of bread.

// repeatEnd

// 
// Given a string and an int n, return a string made of n repetitions of the last 
// n characters of the string. You may assume that n is between 0 and the length o
// f the string, inclusive.

// xyzMiddle

// 
// Given a string, does "xyz" appear in the middle of the string? To define middle
// , we'll say that the number of chars to the left and right of the "xyz" must di
// ffer by at most one. This problem is harder than it looks.

// endOther

// 
// Given two strings, return true if either of the strings appears at the very end
//  of the other string, ignoring upper/lower case differences (in other words, th
// e computation should not be "case sensitive"). Note:  str.toLowerCase() returns
//  the lowercase version of a string.

// --- String-3


// maxBlock

// 
// Given a string, return the length of the largest "block" in the string. A block
//  is a run of adjacent chars that are the same.

// gHappy

// 
// We'll say that a lowercase 'g' in a string is "happy" if there is another 'g' i
// mmediately to its left or right. Return true if all the g's in the given string
//  are happy.

// sumDigits

// 
// Given a string, return the sum of the digits 0-9 that appear in the string, ign
// oring all other characters. Return 0 if there are no digits in the string. (Not
// e: Character.isDigit(char) tests if a char is one of the chars '0', '1', .. '9'
// . Integer.parseInt(string) converts a string to an int.)

// sameEnds

// 
// Given a string, return the longest substring that appears at both the beginning
//  and end of the string without overlapping. For example, sameEnds("abXab") is "
// ab".

// equalIsNot

// 
// Given a string, return true if the number of appearances of "is" anywhere in th
// e string is equal to the number of appearances of "not" anywhere in the string 
// (case sensitive).

// withoutString

// 
// Given two strings, 

// sumNumbers

// 
// Given a string, return the sum of the numbers appearing in the string, ignoring
//  all other characters. A number is a series of 1 or more digit chars in a row. 
// (Note: Character.isDigit(char) tests if a char is one of the chars '0', '1', ..
//  '9'. Integer.parseInt(string) converts a string to an int.)

// mirrorEnds

// 
// Given a string, look for a mirror image (backwards) string at both the beginnin
// g and end of the given string. In other words, zero or more characters at the v
// ery begining of the given string, and at the very end of the string in reverse 
// order (possibly overlapping). For example, the string "abXYZba" has the mirror 
// end "ab".

// countTriple

// 
// We'll say that a "triple" in a string is a char appearing three times in a row.
//  Return the number of triples in the given string. The triples may overlap.

// notReplace

// 
// Given a string, return a string where every appearance of the lowercase word "i
// s" has been replaced with "is not". The word "is" should not be immediately pre
// ceeded or followed by a letter -- so for example the "is" in "this" does not co
// unt. (Note: Character.isLetter(char) tests if a char is a letter.)

// countYZ

// 
// Given a string, count the number of words ending in 'y' or 'z' -- so the 'y' in
//  "heavy" and the 'z' in "fez" count, but not the 'y' in "yellow" (not case sens
// itive). We'll say that a y or z is at the end of a word if there is not an alph
// abetic letter immediately following it. (Note: Character.isLetter(char) tests i
// f a char is an alphabetic letter.)

// --- Array-3


// maxMirror

// 
// We'll say that a "mirror" section in an array is a group of contiguous elements
//  such that somewhere in the array, the same group appears in reverse order. For
//  example, the largest mirror section in {1, 2, 3, 8, 9, 3, 2, 1} is length 3 (t
// he {1, 2, 3} part). Return the size of the largest mirror section found in the 
// given array.

// maxSpan

// 
// Consider the leftmost and righmost appearances of some value in an array. We'll
//  say that the "span" is the number of elements between the two inclusive. A sin
// gle value has a span of 1. Returns the largest span found in the given array. (
// Efficiency is not a priority.)

// linearIn

// 
// Given two arrays of ints sorted in increasing order, 

// fix34

// 
// Return an array that contains exactly the same numbers as the given array, but 
// rearranged so that every 3 is immediately followed by a 4. Do not move the 3's,
//  but every other number may move. The array contains the same number of 3's and
//  4's, every 3 has a number after it that is not a 3, and a 3 appears in the arr
// ay before any 4.

// seriesUp

// 
// Given n&gt;=0, create an array with the pattern {1,    1, 2,    1, 2, 3,  
//  ... 1, 2, 3 .. n} (spaces added to show the grouping). Note that the length o
// f the array will be 1 + 2 + 3 ... + n, which is known to sum to exactly n*(n + 
// 1)/2.

// countClumps

// 
// Say that a "clump" in an array is a series of 2 or more adjacent elements of th
// e same value. Return the number of clumps in the given array.

// squareUp

// 
// Given n&gt;=0, create an array length n*n with the following pattern, shown her
// e for n=3 : {0, 0, 1,    0, 2, 1,    3, 2, 1} (spaces added to show the 3 g
// roups).

// canBalance

// 
// Given a non-empty array, return true if there is a place to split the array so 
// that the sum of the numbers on one side is equal to the sum of the numbers on t
// he other side.

// fix45

// 
// (This is a slightly harder version of the fix34 problem.) Return an array that 
// contains exactly the same numbers as the given array, but rearranged so that ev
// ery 4 is immediately followed by a 5. Do not move the 4's, but every other numb
// er may move. The array contains the same number of 4's and 5's, and every 4 has
//  a number after it that is not a 4. In this version, 5's may appear anywhere in
//  the original array.







